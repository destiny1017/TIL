## CPU 스케줄링

- CPU 스케줄링은 CPU사용에 대한 권한을 여러 프로세스들에게 분배하여 효과적인 다중 프로그래밍을 구현할 수 있게 하는 기법이다.
- CPU 스케줄링의 목적은 CPU를 유휴 상태로 낭비하는 시간 없이 최대로 활용하여 다중 프로세스의 처리를 효율적으로 수행할 수 있도록 하는 것이다.

### 프로세스 스케줄링 과정
![img.png](../assets/process_exec_cycle.png)
- 프로세스는 실행되면 종료되기 전까지 준비 상태, 실행 상태, 대기 상태를 전환하며 작업을 수행한다.
- **준비 상태**
  - CPU를 할당 받기 위해 준비 큐에서 스케줄러의 선택을 기다리는 상태
  - 준비 큐는 반드시 FIFO 입출력 구조가 아닌 알고리즘에 따라 여러 방식으로 구현된다
  - 일반적으로 메모리에 적재되어 있고 실행 가능한 상태의 프로세스들이 준비 상태에 있는다.
- **실행 상태**
  - CPU를 할당 받아 실제 코드를 실행하고 있는 상태
  - 실행 상태인 프로세스는 한번에 단 하나의 프로세스만 존재할 수 있다(1코어 기준)
- **대기 상태**
  - CPU가 아닌 다른 이벤트를 기다리고 있는 상태
  - 일반적으로 I/O 작업이 일어난 경우 I/O의 완료 이벤트까지 대기 상태로 기다리게 되며, 다른 이벤트를 기다릴 수도 있다.
  - 대기 상태가 종료되면 준비 상태로 갈 수도 있지만 상황에 따라 바로 실행 상태로 갈수도 있다

### 스케줄링 주기에 따른 스케줄러의 종류

- **장기 스케줄링(Long-term scheduler)**
  - 메모리에 동시에 올라가 있는 프로세스 수를 조절하는 역할
  - 시작상태(new)의 프로세스를 준비상태(ready)로 전환할지 여부를 결정한다
  - 메모리가 매우 작던 과거에 많이 쓰이던 방식으로, 현재에는 거의 쓰이지 않는다.
  
- **중기 스케줄링(Medium-term scheduler, Swapper)**
  - 현대의 운영체제에서 장기 스케줄러 대신 사용하는 스케줄러이다
  - 너무 많은 프로세스가 메모리에 올라와 각각의 프로세스가 갖는 메모리가 지나치게 적어지는 경우를 방지하기위해 동적으로 프로세스 수를 조절한다.
  - 프로세스가 너무 많으면 중요도가 떨어지는 프로세스들을 메모리 영역에서 디스크 영역으로 내보낸다(swap)
    - swap의 0순위 대상 프로세스는 I/O작업 등에 의해 봉쇄(block, sleep)상태인 프로세스들이다.
    - 그 다음 순위는 타이머 인터럽트로 인해 실행 상태에서 준비상태로 빠지는 프로세스이다.
  - 중기 스케줄러에의해 프로세스의 상태에 중지 봉쇄(Suspended blocked) 상태와 중지 준비(Suspended ready) 상태가 추가된다.
    - 중지 봉쇄 상태 : 봉쇄(blocked) 상태에 있던 프로세스가 디스크로 스왑된 상태
    - 중지 준비 상태 : 준비(ready) 상태에 있던 프로세스가 디스크로 스왑된 상태
    - 중지 봉쇄 상태에서 봉쇄 해제 조건을 만족하면(I/O 완료 등) 중지 준비 상태로 이동
  
  > ***중지상태가 추가된 프로세스의 상태 흐름**  
  > ![img.png](../assets/suspended_status.png)
  
- **단기 스케줄링(Short-term scheduler, CPU scheduler)**
  - 가장 많이 호출되고 가장 작은 단위(밀리초)로 호출되는 스케줄러이다
  - CPU를 할당받는 프로세스를 선정하는 스케줄러이므로  CPU 스케줄러라고도 한다.
  - 다양한 스케줄링 알고리즘이 존재하며, 적합한 알고리즘 적용 여부에 따라 시스템 성능이 크게 좌우된다.
  

### 비선점 / 선점 스케줄링
- CPU 스케줄링은 다음 네 가지 상황에 발생할 수 있다.
  - 한 프로세스가 실행 상태에서 대기 상태로 전환될 때
  - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때(예: 인터럽트 발생)
  - 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때(예: I/O 종료 시)
  - 프로세스가 종료할 때
- 이 중 1, 4번째 상황은 선택의 여지가 없이 반드시 다른 프로세스가 실행상태로 진입해야 한다. 이러한 상황에서만 스케줄링이 일어나는 것을 **비선점 스케줄링**이라 한다.
- 반면 2, 3번 상황에서 스케줄링이 발생하는 경우는 상황에 따라 현재 실행 상태인 프로세스를 밀어내고 다른 프로세스가 실행될 수도 있어 이런 스케줄링은 **선점 스케줄링**이라 한다.
- window, mac, linux 등 대부분의 OS는 선점형 스케줄링을 사용한다.

### 스케줄링 기준
- 스케줄링은 우선 순위를 판단하기 위한 아래와 같은 5가지 기준을 사용한다.
  - 대기시간(waiting time): 프로세스가 생성된 후 실행되기 전까지 대기하는 시간(준비 큐에서 대기한 시간)
  - 평균 대기 시간: 모든 프로세스의 대기 시간을 합한 뒤 프로세스의 수로 나눈 값
  - 응답 시간(response time): 첫 작업을 시작한 후 첫 번째 출력(반응)이 나오기 전까지 시간
  - 실행시간: 프로세스 작업이 시작된 후 종료되기까지의 시간
  - 반환시간(turn around time): 대기 시간을 포함하여 실행이 종료될 때까지의 시간
  ![img.png](../assets/scheduling_factor.png)

### 스케줄링 알고리즘
- 스케줄링이 일어나 프로세스를 준비 큐에 삽입할 때 어떤 기준으로 어디에 삽입할 건지를 결정하는 다양한 알고리즘이 있다.
- #### 비선점 알고리즘
  - **FCFS(First Come First Served)**
    - 먼저 CPU점유를 요청하는 순서대로 스케줄링하는 방식
    
      |     | 수행시간 | 대기시간 | 반환시간 |
      |------|------|------|------|
      | P1  | 15   | 0    | 15   |
      | P2  | 5    | 15   | 20   |
      | P3  | 3    | 20   | 23   |
    - 위와 같은 프로세스 요청이 있을 때, **평균 대기 시간은 (0 + 15 + 20) / 3 = 11.7 이다.
    - 만일 P3-P2-P1 순서로 실행이 됐다면 평균 대기 시간은 (0 + 3 + 8) / 3 = 2.7 이다.
    - 즉 수행시간 시간에 따라 평균 대기 시간이 바뀐다.
  - **SJF(Shortest Job First)**
    - 수행 시간이 짧은 프로세스부터 CPU를 할당하는 방식
    - 평균 대기 시간을 최소화 하기위해 사용한다
    
      |     | 수행시간 | 대기시간 | 반환시간 |
      |------|------|------|------|
      | P1  | 6   | 3    | 9   |
      | P2  | 3    | 0    | 3   |
      | P3  | 8    | 16   | 24   |
      | P4  | 7    | 9    | 16   |
    - 위와 같은 프로세스가 있을 때 실행 순서는 P2 → P1 → P4 → P3 순서가 된다.
    - 평균 대기 시간은 (3 + 0 + 16 + 9) / 4 = 7 으로, 들어오는 순서와 상관없이 항상 동일하다.
    - SJF는 준비 큐에 있는 프로세스들만을 기준으로 하여 비선점이지만, SJF와 비슷한 SRTF(Shortest Remaining Time First)는 새로 도착한 프로세스의 수행시간이 현재 실행중인 프로세스보다 짧다면 CPU사용을 선점하는 식으로 동작한다.


- #### 선점 알고리즘
  - 선점형 스케줄링은 아래와 같은 공통적인 룰이 있다.
    - 높은 우선순위를 갖는 프로세스는 항상 먼저 스케줄되어야 한다.
    - I/O Bound 프로세스는 CPU Bound 프로세스보다 반드시 높은 우선순위에 있어야 한다.
    - Time Slice시에는 프로세스의 수행시간보다 조금만 더 많아야 한다.
    - Real-Time 프로세스는 다른 프로세스보다 매우 높은 우선순위를 갖는다.
  - **SRT(Shortest Remaining Time)**
    - 최단 잔여시간을 우선으로 하는 스케줄링
    - 프로세스 도착시마다 실행중인 프로세스까지 포함하여 잔여시간을 계산, 가장 짧은 잔여시간인 프로세스가 CPU를 선점하는 방식
    - 선점형 SJF라고도 불린다.
    
      |     |도착시간 | 수행시간 | 종료시간 | 대기시간 | 반환시간 |
      |-----|------|------|------|------|------|
      | P1  |1| 8    | 17   | 9    | 17   |
      | P2  |2| 4    | 5    | 0    | 4    |
      | P3  |3| 9    | 26   | 15   | 24   |
      | P4  |4| 5    | 10   | 2    | 7    |
    - 위와 프로세스는 아래의 그림과 같이 수행된다.

      ![img.png](../assets/SRT_process.png)
  - **RR(Round Robin)**
    - 모든 프로세스가 같은 우선순위를 갖고, time slice를 기반으로 스케줄링 한다.
    - time slice가 일어나면 실행중인 프로세스는 중단되고, 준비 큐의 끝으로 이동한다.

      |     | 수행시간 | 대기시간 | 반환시간 |
      |------|------|------|------|
      | P1  | 13   | 10   | 23   |
      | P2  | 7    | 3    | 10   |
      | P3  | 3    | 12   | 15    |
    - 위와 같은 프로세스는 아래의 그림과 같이 수행된다.

      ![img_1.png](../assets/RR_process.png)
    - Time slice 기준 값이 너무 커 가장 수행시간이 긴 프로세스보다 크다면 SJSF와 동일하게 동작한다.
    - Time slice 기준 값이 너무 작다면 Context Switch가 너무 빈번하게 발생하여 성능이 저하된다.
  
    

- #### 우선순위 스케줄링
  - 우선순위 스케줄링이란 준비 큐의 프로세스들 중 우선순위가 가장 높은 프로세스에게 가장 먼저 CPU를 할당하는 방식을 의미한다.
  - 우선순위 값은 여러가지가 될 수 있으며, 만일 우선순위를 수행시간으로 설정하면 SJF와 동일한 알고리즘이 된다.\
  - 우선순위 스케줄링 역시 선점과 비선점으로 나눌 수 있다.
  - **우선순위 스케줄링의 문제점**
    - 기아상태(starvation)
      - 우선순위 스케줄링은 우선순위가 낮게 책정된 프로세스가 새로 들어온 우선순위가 높은 프로세스들에 밀려 무한히 대기하는 기아현상이 발생할 수 있다.
    - 기아상태 해결법
      - 기아상태 해결을 위해서는 노화(aging) 기법을 사용할 수 있다. 노화 기법이란 기다리는 시간이 길어질수록 우선순위를 조금씩 높여 언젠가는 가장 우선순위가 높은 프로세스가 될 수 있게 하는 기법이다.
      - 이러한 노화 기법을 적용한 스케줄링 기법을 HRN 스케줄링이라 한다.

  
- #### 멀티레벨 큐(Multi-level queue)
    ![img.png](../assets/multi_level_queue.png)  
  - 멀티레벨 큐란 준비 큐를 여러개로 분할해 관리하는 스케줄링 기법이다.
  - 멀티레벨 큐는 작업의 성격이 다른 프로세스들을 별도로 관리하고 성격에 맞는 스케줄링을 적용하기 위해 구현한다.
  - 일반적으로 멀티레벨 큐는 즉각 응답이 필요한 대화형 작업을 전위 큐로 두고, 계산 위주의 작업을 후위 큐로 두는 방식을 사용한다.
  - 전위 큐는 라운드 로빈 방식 스케줄링을 적용하여 빠르게 프로세스를 수행하고, 후위 큐는 FCFS방식을 적용하여 컨택스트 스위칭 비용을 줄인다.
  - 멀티레벨 큐에서는 큐 자체에 대한 스케줄링도 필요한데, 일반적으로는 고정우선순위 방식을 사용한다. 이 방식에서는 전위 큐의 프로세스를 모두 처리하고 나야만 후위 큐의 작업이 수행된다.
  - 고정우선순위 방식 외에 라운드 로빈 방식을 사용하여, 시간을 다르게 분배하는 식으로 활용할 수도 있다. 전위큐에 80%의 시간을, 후위큐에 20% 시간을 주는 식이다.

  
- #### 멀티레벨 피드백 큐(Multi-level feedback queue)
    ![img_1.png](../assets/multi_level_feedback_queue.png)  
  - 멀티레벨 피드백 큐는 멀티레벨 큐처럼 여러개의 준비큐를 사용하지만, 준비큐간의 프로세스 이동이 가능하다는 특징을 갖는다.
  - 대표적으로 기아현상 해결법인 노화기법을 적용하여, 대기 시간이 길어질 수록 우선순위가 높은 큐로 이동시키는 방식 등이 있다.
  - 일반적으로 우선순위가 높은 큐에는 짧은 타임슬라이스의 라운드 로빈을, 그 다음 큐는 조금 더 긴 타임슬라이스의 라운드 로빈을 두는 식으로 큐를 구성하고, 마지막에는 FCFS큐를 둔다.
  - 먼저 최상위 큐로 프로세스가 진입했다가 버스트 시간에 따라 시간이 길다면 하위 큐로 내려가는 식으로 배정한다.

  