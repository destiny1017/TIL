## 메모리 관리(Memory Management)

운영체제에서 프로그램을 실행하면 해당 프로그램의 데이터는 메모리(RAM)에 로드된다. 이 때 메모리 공간은 한정적이기 때문에, 어떤 데이터를 메모리에 올릴지, 각 프로그램의 메모리 주소를 어떻게 구분할지, 어떤 프로그램에게 더 많은 공간을 줄지 등등 수많은 고려사항이 필요하다. 운영체제는 이러한 메모리 관리를 자동적으로 수행하는 다양한 기법을 갖고 있으며, 그 덕분에 사용자는 메모리에 신경을 쓰지 않고 편하게 컴퓨터를 이용할 수 있게 되는 것이다. 이러한 메모리 관리 기법에는 어떤 것들이 있는지 하나씩 알아보자.

### 주소바인딩
프로그램이 메모리에 적재되면 그 프로그램만의 독자적인 주소 공간이 생성된다. 이 주소 공간을 논리적 주소(logical address) 또는 가상 주소(virtual address)라고 한다. 그리고 cpu는 이 논리 주소에 근거해 프로그램을 실행하게 된다. 실제 데이터가 올라가는 위치인 물리 주소는 cpu가 참조하지 않으며, 오직 논리주소만을 참조하여 프로그램을 실행한다.  

이 두가지의 주소영역, 물리적 주소와 논리적 주소를 연결시켜주는 방식을 주소 바인딩이라고 하며, 주소 바인딩은 물리 메모리에 적재되는 시기에 따라 아래와 같은 세가지 방식으로 구분할 수 있다.  

#### 1. 컴파일 타임 바인딩(compile time binding)
프로그램이 컴파일을 하는 시점에 물리적 메모리의 몇번지에 위치할 것인지를 결정한다.  
절대주소에 적재된다고하므로 절대코드(absolute code)를 생성하는 바인딩 방식이라고 말하기도 한다.  
만일 실행중 메모리 위치를 변경하고 싶을 경우 컴파일을 다시해야하는 문제가 있어 현재의 시분할 시스템에서는 거의 사용되지 않는 기법이다.

#### 2. 로드 타임 바인딩(load time binding)  
프로그램의 실행이 시작될 때 물리적 메모리 주소가 결정되는 바인딩 방식이다.  
로더(loader)에 의해 물리적 메모리가 부여되며, 프로그램 종료시까지 주소가 고정된다.  
컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 기법이다.
  
#### 3. 실행시간 바인딩(run time binding)
프로그램 실행 중에도 그 프로그램의 물리적 메모리 주소가 변경될 수 있는 바인딩 기법이다.
CPU가 주소를 참조할 때마다 주소 매핑 테이블(address mapping table)을 이용하여 바인딩을 점검해야 한다.  
실시간 바인딩을 위해서는 기준 레지스터와 한계 레지스터, MMU라는 하드웨어적인 지원이 필요하다.


### MMU(Memory Management Unit)
MMU는 cpu에게 받은 논리 주소를 기반으로 실제 물리주소를 찾아가기위한 장치로서, 각각의 프로그램이 동일한 논리주소를 갖고 있더라도 기준레지스터와 조합하여 별도의 물리주소를 찾아가도록 할 수 있다.  
![img.png](img.png)  
MMU가 메모리를 찾아가는 방식은 위의 그림과 같다. 먼저 CPU가 논리 메모리주소 346에 대한 데이터를 요청하면, MMU는 이 346의 논리주소를 재배치(기준) 레지스터의 값과 조합하여, 14346이라는 물리 주소를 얻은 뒤 메모리에 해당 주소의 데이터를 요청한다.
여기서, 재배치 래지스터의 값의 기준은 현재 CPU를 점유하고 있는 프로세스를 기준으로 값이 설정되며, 그러므로 컨텍스트 스위칭이 발생할 때마다 재배치 레지스터의 값도 변하게 된다.  

#### * 한계 레지스터(limit register)  
![img_1.png](img_1.png)
하지만 위 방식으로 메모리 주소를 변환하다 보면 변환 결과가 해당 프로세스가 가질 수 있는 메모리 주소 영역을 벗어나는 연산 결과가 나올수도 있다. 이런 경우를 대비해서 MMU는 한계 레지스터의 도움을 받는데, 한계 레지스터는 해당 프로세스가 가질 수 있는 주소 범위를 기록해두고, 매 논리 주소 요청이 올 때마다 이 범위를 벗어나는지 확인하여 만일 벗어난다면 트랩을 발생시켜 해당 프로세스를 종료시키게 하는 역할을 한다.
  

