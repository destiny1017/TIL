이펙티브 자바, Joshua Bloch
===

## 2장. 객체 생성과 파괴
### 1. 생성자 대신 정적 팩터리 메서드를 고려햐라   
 - 정적 팩터리 메서드가 가지는 장점 5가지
   - 이름을 가질 수 있어 생성 행위의 필요조건과 결과를 좀 더 명시적으로 드러낼 수 있다.
   - 호출될 떄마다 인스턴스를 새로 생성하지 않아도 된다. 플라이 웨이트 패턴 등을 통해 빈번한 생성이 일어나는 객체를 캐싱하여 생성 비용을 줄일 수 있다.
   - 반환 타입의 하위 객체(자식클래스)를 반환할 수 있는 능력이 있다. 이는 인터페이스화를 통해 매우 뛰어난 유연성을 가져갈 수 있는 특징이 된다.
   - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 위의 장점과 마찬가지로 이는 객체 생성의 유연성을 크게 증가시킨다.
   - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. JDBC와 같은 서비스 제공자 프레임워크를 만드는 근간이 되는 기술로서, 추후에 새로운 클래스가 추가돼도 변경 클라이언트는 없이 팩터리 메서드 사용이 가능하다.
 - 정적 팩터리 메서드의 단점
   - 상속을 하려면 public이나 protected 생성자가 필요해 상속이 불가능해진다. 다만 이는 상속보다 조합을 강제하여 오히려 장점이라 볼수도 있따.
   - 정적 팩터리 메서드를 프로그래머가 찾기가 어렵다. 이를 위해 공통 규약을 따라 팩터리 메서드를 설계하는 게 좋다.

   ```java
   class StaticFactoryMethod {
   
      // from : 하나의 매개변수, 해당 타입의 인스턴스 반환
      Date d = Date.from(instant);
      
      // of : 여러 매개변수, 적합한 인스턴스 반환
      Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
      
      // valueOf : from과 of의 더 자세한 버전
      BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
      
      // instance or getInstance : 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않음
      StackWalker luke = StackWalker.getInstance(options);
      
      // create or newInstance : instance 혹은 getInstance와 같지만 매번 새로운 인스턴스를 반환한다.
      Object newArray = Array.newInstance(classObject, arrayLen);
      
      // get[Type] : getInstance와 같으나, 다른 클래스에서 생성할 때 쓴다.
      FileStore fs = Files.getFileStore(path);
   
      // new[Type] : newInstance와 같으나, 다른 클래스에서 생성할 때 쓴다.
      BufferedReader br = Files.newBufferedReader(path);
      
      // [type] : getType과 newType의 간결한 버전
      List<Complaint> litany = Collections.list(legacyLitany);
   
   }
   ```

### 2. 생성자에 매개변수가 많다면 빌더를 고려하라
- 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다. setter를 이용한 자바 빈즈 패턴을 통해 이를 해결할수도 있지만 이는 클래스가 완성되기 전까지 클래스의 불변성을 보장하기가 어렵다. 빌더 패턴을 사용하자.
- 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기 좋다. 제네릭과 상속을 활용하여 하위 클래스에서 빌더가 반환할 빌더 클래스를 재정의하여 사용하자.
- 빌더 패턴이 매개변수가 많아 졌을 때 사용하면 좋지만, API는 시간이 지날수록 매개변수가 많아지는 특성이 있다. 그러니 웬만하면 처음부터 빌더 패턴으로 설계를 하는 게 좋다.

### 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라.
- 싱글턴을 만드는 방법은 public static final 필드를 통해 인스턴스를 제공하는 방법과, 정적 팩터리 메서드를 통해 제공하는 방법이 있다.
- 필드방식의 장점은 해당 필드가 싱글턴임이 API에 명백히 드러난다는 것이고, 간결하다는 것 또한 장점이다.
- 정적 팩터리 방식의 장점은 API를 변경하지 않고도 싱글턴 여부를 변경할 수 있다는 것이다. 또한 스레드별로 다른 인스턴스를 넘겨줄 수도 있다.
- 둘 중 하나의 방식으로 구현한 클래스를 직렬화하려면, Serializable을 구현하는 것만으로는 부족하고, readResolve 메서드를 제공해야 역직렬화마다 가짜 객체가 생성되는 것을 방지할 수 있다.
   ```java
   // 싱글턴임을 보장해주는 readResolve 메서드
   private Object readResolve() {
       // 진짜 객체를 반환하고, 가짜 객체는 가비지 컬렉터에 맡긴다.
       return INSTANCE;
   }
   ```
- 싱글턴을 만드는 세번째 방법은 Enum타입을 선언하는 것이다.
   ```java
   public enum Elvis {
       INSTANCE
       public void leaveTheBuilding() {...}
   }
   ```
- 리플렉션 공격을 피할 수 있고, 추가적인 노력 없이 직렬화 할 수 있으나 Enum이외의 클래스를 상속할 수 없다는 단점이 있다.
- Enum 상속이 필요한 상황이 아니라면 Enum 싱글턴이 최선의 선택이다.

### 4. 인스턴스화를 막으려거든 private 생성자를 사용하라
- 정적 메서드와 정적 필드만을 담은 클래스와 같이 인스턴스화를 시키지 않는 클래스는 private 기본 생성자를 선언하여 인스턴스화를 막아라.
- 이 방식은 인스턴스화 불가 효과에 더해 상속 불가 효과도 갖는다.
- 다만 이런 방식은 비직관적이니 생성자에 목적을 주석으로 달아주는 것이 좋다.

### 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스의 동작에 영향을 준다면 싱글턴이나 정적 유틸리티 클래스는 사용하지 말자.
- 의존 객체 주입은 생성자에 필요한 자원을 넘겨주는 방식으로, 이미 많은 개발자들이 사용중인 패턴이다.
- 다만 자원이 너무 많다면 코드가 복잡해지는 문제가 있는데, 스프링과 같은 프레임워크를 사용하면 이같은 문제를 해결할 수 있다.

### 6. 불필요한 객체 생성을 피하라
- 특정 동작의 수행을 위해 사용하는 코드가 내부적으로 매번 새로운 객체를 생성하는 경우(ex. matches) 필요한 객체를 필드에 초기화 시켜 재사용하라.
- 기본타입을 래퍼객체로 변환해주는 오토박싱은 빈번한 호출에 사용될 시 불필요한 객체를 크게 양산할 수 있다. 가급적 기본타입을 사용하고 오토박싱이 숨어들지 않도록 주의하자.

### 7. 다 쓴 객체 참조를 해제하라
- JVM만 믿고 객체 생명주기를 신경쓰지 않다보면 자바에서도 메모리 누수가 일어날 수 있다.
- 로직상 프로그래머만 객체의 미사용 여부를 알 수 있고 JVM은 알 수 없는 케이스(ex. 리스트내 잔존 객체, 캐시 데이터)를 잘 파악하여 직접 참조해제를 해주자.
- 다만 이런 위험을 예방하기위해 모든 객체를 직접 참조 해제하는 것은 바람직하지 못하다. 직접 해제는 예외적인 경우에만 하자.
 


### 8. finalizer와 cleaner 사용을 피하라
- finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
- cleaner는 finalizer 보다는 덜 위험하지만 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.
- cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자. 물론 이런 경우라도 불확실성과 성능저하에는 주의해야 한다.

### 9. try-finally보다는 try-with-resource를 사용하라
- try-finally는 해제해야 하는 자원이 여러개일 시 중첩 블록이 발생하여 코드가 지저분해질 수 있다.
- 또한 중첩 try-finally 블록에서는 안쪽 블록에서 발생한 catch 예외를 바깥쪽 catch가 덮어버려 예외 추적이 힘들어진다.
- try-with-resource를 사용하면 여러 자원을 훨씬 깔끔하게 해제할 수 있고, 덮어씌워진 예외 또한 확인 가능해진다.
- 만일 직접 작성한 클래스도 자원 해제가 필요하다면 AutoCloseable 인터페이스를 구현하여 try-with-resource를 사용하자.


## 3장. 모든 객체의 공통 메서드
### 10. equals는 일반 규약을 지켜 재정의하라
- equals 메서드는 아래와 같은 상황중 하나에 해당한다면 재정의하지 않는 것이 최선이다.
  - 각 인스턴스가 본질적으로 고유하다.
  - 인스턴스의 논리적 동치성(logical equality)를 검사할 필요가 없다.
  - 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
  - 클래스가 private이거나 package-private이고 equals메서드를 호출할 일이 없다.
- equals를 재정의해야 할 때는 클래스의 논리적 동치성을 확인해야하는데, 상위 클래스가 equals를 재정의하지 않았을 때이다.
- equals메서드는 동치관계를 구현하며, 다음을 만족한다.
  - 반사성(reflexivity): null이 아닌 모든 참조 값 x에 대해 x.equals(x)는 true다.
  - 대칭성(symmetry): null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)가 true면 y.equals(x)도 true이다.
  - 추이성(transitivity): null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true이고, y.equals(z)도 true이면, x.equals(z)도 true이다.
  - 일관성(consistency): null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.
  - null-아님: null이 아닌 모든 참조값 x에 대해, x.equals(null)은 false이다.
- 클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다. 이 제약을 어기면 일관성을 만족시키기가 아주 어렵다.
- 양질의 equals 메서드 구현법은 아래와 같다.
  - == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
  - instanceof 연산자로 입력이 올바른 타입인지 확인한다.
  - 입력을 올바른 탕비으로 형변환한다.
  - 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.

### 11. equals를 재정의하려거든 hashcode도 재정의하라
- equals를 재정의하고 hashcode를 재정의하지 않는다면, HashMap이나 HashSet같은 자료구조의 원소로 사용시 문제를 일으킬 것이다.
- 아래는 Object 명세에서 발췌한 규약이다.
  - equals 비교에 사용되는 데이터가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashcode는 몇 번을 호출해도 항상 같은 값을 반환해야 한다.
  - equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashcode는 똑같은 값을 반환해야 한다.
  - equals(Object)가 두 객체를 다르다고 판단했더라도 두 객체의 hashcode가 반드시 다른 값을 반환해야할 필요는 없지만 성능을 위해서는 다른 값을 반환하는 게 좋다.
- 올바른 hashcode 메서드를 작성하는 규칙은 다음과 같다.
   - 첫번째 핵심필드 값의 해시코드를 구한다.
   - 첫번째 해시코드 값에 *31을 하고, 다음 핵심 필드의 해시코드 값을 구하여 더한다.
   - 위 과정을 모든 핵심 필드를 계산할 떄 까지 반복한다.
   - 이 과정을 거친 해시코드 메서드는 아래와 같은 형태가 된다.
   ```java
   @Override
   public int hashcode() {
       int result = Short.hashCode(areaCode);
       result = 31 * result + Short.hashCode(prefix);
       result = 31 * result + Short.hashCode(lineNum);
       return result;
   }
   ```
- Object 클래스는 임의의 개수만큼 객체를 받아 해시코드를 계산해주는 hash 메서드를 제공하지만, 성능이 아쉬우므로 성능 이슈가 없을 때만 활용하자.
- 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다.
- hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 않아야 클라이언트가 이 값에 의지하지 않게 되고, 추후 계산 방식을 바꿀 수도 있다. 
- ***equals 재정의와 hashCode 재정의를 모두 간편하게 할 수 있게 도와주는 AutoValue 프레임워크를 적극적으로 활용하자.***

### 12. toString을 항상 재정의하라
- toString의 일반 규약에 따르면 toString은 '간결하면서 사람이 읽기 쉬운 형태의 유익한 정보'를 제공해야한다.
- 하지만 재정의 하지 않은 Object 클래스의 toString 메서드는 전혀 가치가 없는 주소값을 제공하므로 필드의 정보들을 제공하도록 재정의하자.
- 재정의시 포맷의 지정은 자유이나, 포맷에 대한 의도는 명확히 밝혀야한다. 주석으로 어떤 포맷을 따라 작성해야하는지, 자유라면 자유롭게 작성하라든지 정보를 남기자.
- 이 또한 AutoValue를 사용하면 간편하게 재정의할 수 있는데, 일부 개발자만 의미를 파악할 수 있는 필드에 대해서는 직접 작성해야한다.

### 13. clone 재정의는 주의해서 진행하라
- Cloneable 인터페이스는 많은 문제를 지니고 있으므로 새로운 인터페이스를 만들 때는 절대 Cloneable 인터페이스를 확장하지 말자.
- 대부분의 경우에는 clone메서드 보다 복사 생성자나 복사 팩터리를 사용하는 게 더 올바른 선택이다.
- 다만 배열만은 clone을 활용하는 게 가장 깔끔한, 합당한 예외라고 할 수 있다.

### 14. Comparable을 구현할지 고려하라
- 순서를 고려해야하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여, 그 인스턴스들을 쉽게 정렬하고, 검색하고, 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다.
- compareTo 메서드를 구현할 때 비교연산자를 이용하기 보다는 자바7 이후에 추가된 compare 메서드를 적극 활용하자.
- compareTo 메서드도 equals 메서드와 같이 반사성, 동치성, 추이성을 충족해야 한다. comapareTo의 결과가 equals와 일관되는 게 좋지만 이 규칙이 필수는 아니다.


## 4장. 클래스와 인터페이스
### 15. 클래스와 멤버의 접근 권한을 최소화하라
- 객체지향 프로그램 설계의 근간이 되는 정보은닉, 캡슐화를 지키기면 아래와 같은 이점이 있다.
  - 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문.
  - 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빠르게 파악할 수 있고, 교체에 대한 부담도 적다.
  - 소프트웨어 재사용성을 높인다. 외부에 거의 의존하지 않는 컴포넌트는 낯선 환경에서도 유용하게 쓰일 수 있다.
  - 큰 시스템을 제작하는 난이도를 낮춘다. 각 컴포넌트 개별의 동작을 검증할 수 있기 때문이다.
- 기본 원칙은 모든 클래스와 멤버의 접근성을 가능한한 좁혀야 한다는 것이다.
- 접근 레벨을 public으로 두는 순간 이는 공개 API임을 선언하는 것이므로 항상 관리되어야 한다.
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다. 그리고 상수 필드도 객체를 참조한다면 그 객체는 불변객체여야만 한다.

### 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
- public 클래스는 절대 가변 필드를 노출해서는 안 된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
- 다만 private 클래스나 package-private 클래스에서만 사용하는 클래스의 경우에는 필드를 노출하는 편이 나을 때도 있다.

### 17. 변경 가능성을 최소화하라
- 불변 클래스는 가변 클래스보다 설계, 구현, 사용이 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.
- 클래스를 불변으로 만드려면 다음 다섯가지의 규칙을 따르면 된다.
  - 객체의 상태를 변경하는 메서드를 제공하지 않는다.
  - 클래스를 상속할 수 없도록 한다.
  - 모든 필드를 final로 선언한다.
  - 모든 필드를 private으로 선언한다.
  - 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
- 이러한 불변 객체는 근본적으로 thread-safe하여 따로 동기화할 필요가 없다.
- 다만 불변객체의 대표적인 단점으로는 미미한 차이의 값에도 객체를 매번 새로 생성해야한다는 점이 있다. 이는 자주 사용될 다단계 연산을 기본 기능으로 제공하는 방법 등으로 완화할 수 있다.
- 상속을 불가능하게하기 위해 생성자를 private으로 선언하고, 정적 팩터리 메서드를 제공하여 객체를 생성하도록 하자.
- 생성자와 정적 팩터리 메서드를 제외하고는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.

### 18. 상속보다는 컴포지션을 사용하라
- 상속은 객체의 캡슐화를 해친다는 문제가 있다. 상위 클래스와 하위 클래스간의 관계가 is-a 관계가 아닌 이상 상속은 사용하지 말자.
- 다만 is-a 관계라고 하더라도 하위 클래스와 상위 클래스의 패키지가 다르고, 상위 클래스가 확장을 고려하지 않고 설계했다면 여전히 문제가 된다.
- 상속을 사용하려는 대부분의 상황에서 상속 대신 해당 클래스를 private 필드로 선언하는 컴포지션 방식을 사용하면 상속이 갖는 많은 문제를 해결하며 재사용성이라는 장점도 가져갈 수 있다.
- 또한 상속을 대체하는 더 좋은 방법은 래퍼클래스의 활용도 있다. 래퍼 클래스는 하위 클래스보다 견고하고 강력하다.

### 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
- 상속용 클래스는 재정의 가능한 메서드들을 내부적으로 어떻게 이용하는지에 대해 @implSpec 어노테이션을 통해 문서로 남겨야 한다.
- 내부 동작에 끼어들 수 있는 훅(Hook)을 선별하여 protected로 공개해야 큰 어려움 없이 하위클래스에서 기능을 이용할 수 있다.
- 상속용 클래스를 테스트하는 방법은 직접 하위클래스를 만들어보는 것이 유일하므로 반드시 하위 클래스를 생성하여 테스트해보자.
- 상속용 생성자는 절대 재정의 가능한 메서드를 호출해서는 안 된다.
- 상속용 클래스를위해 들여야하는 노력이 상당하므로 웬만하면 상속을 금지하자. 클래스를 final로 선언하거나 private 생성자와 정적 팩토리를 활용하여 금지할 수 있다.

### 20. 추상클래스보다는 인터페이스를 우선하라
- 추상클래스는 다중상속이 불가능하며, 계층화를 강제하여 유연성을 떨어뜨린다.
- 인터페이스는 다중 상속을 통해 손쉽게 새로운 기능을 덧붙일 수 있는 믹스인 정의가 가능하다.
- 자바 8이상부터는 인터페이스에도 default 메서드 사용이 가능하여 추상클래스의 역할을 상당부분 대체할 수 있다.
- 인터페이스가 너무 커진다면 구현의 수고를 덜어주는 골격 구현 클래스를 제공하는 등의 방법을 시도하자. 이를 활용한 예가 템플릿 메서드 패턴이다.