이펙티브 자바, Joshua Bloch
===

## 1장, 객체 생성과 파괴
### 1. 생성자 대신 정적 팩터리 메서드를 고려햐라   
 - 정적 팩터리 메서드가 가지는 장점 5가지
   - 이름을 가질 수 있어 생성 행위의 필요조건과 결과를 좀 더 명시적으로 드러낼 수 있다.
   - 호출될 떄마다 인스턴스를 새로 생성하지 않아도 된다. 플라이 웨이트 패턴 등을 통해 빈번한 생성이 일어나는 객체를 캐싱하여 생성 비용을 줄일 수 있다.
   - 반환 타입의 하위 객체(자식클래스)를 반환할 수 있는 능력이 있다. 이는 인터페이스화를 통해 매우 뛰어난 유연성을 가져갈 수 있는 특징이 된다.
   - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 위의 장점과 마찬가지로 이는 객체 생성의 유연성을 크게 증가시킨다.
   - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. JDBC와 같은 서비스 제공자 프레임워크를 만드는 근간이 되는 기술로서, 추후에 새로운 클래스가 추가돼도 변경 클라이언트는 없이 팩터리 메서드 사용이 가능하다.
 - 정적 팩터리 메서드의 단점
   - 상속을 하려면 public이나 protected 생성자가 필요해 상속이 불가능해진다. 다만 이는 상속보다 조합을 강제하여 오히려 장점이라 볼수도 있따.
   - 정적 팩터리 메서드를 프로그래머가 찾기가 어렵다. 이를 위해 공통 규약을 따라 팩터리 메서드를 설계하는 게 좋다.

   ```java
   class StaticFactoryMethod {
   
      // from : 하나의 매개변수, 해당 타입의 인스턴스 반환
      Date d = Date.from(instant);
      
      // of : 여러 매개변수, 적합한 인스턴스 반환
      Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
      
      // valueOf : from과 of의 더 자세한 버전
      BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
      
      // instance or getInstance : 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지 않음
      StackWalker luke = StackWalker.getInstance(options);
      
      // create or newInstance : instance 혹은 getInstance와 같지만 매번 새로운 인스턴스를 반환한다.
      Object newArray = Array.newInstance(classObject, arrayLen);
      
      // get[Type] : getInstance와 같으나, 다른 클래스에서 생성할 때 쓴다.
      FileStore fs = Files.getFileStore(path);
   
      // new[Type] : newInstance와 같으나, 다른 클래스에서 생성할 때 쓴다.
      BufferedReader br = Files.newBufferedReader(path);
      
      // [type] : getType과 newType의 간결한 버전
      List<Complaint> litany = Collections.list(legacyLitany);
   
   }
   ```

### 2. 생성자에 매개변수가 많다면 빌더를 고려하라
- 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다. setter를 이용한 자바 빈즈 패턴을 통해 이를 해결할수도 있지만 이는 클래스가 완성되기 전까지 클래스의 불변성을 보장하기가 어렵다. 빌더 패턴을 사용하자.
- 빌더 패턴은 계층적으로 설계된 클래스와 함께 쓰기 좋다. 제네릭과 상속을 활용하여 하위 클래스에서 빌더가 반환할 빌더 클래스를 재정의하여 사용하자.
- 빌더 패턴이 매개변수가 많아 졌을 때 사용하면 좋지만, API는 시간이 지날수록 매개변수가 많아지는 특성이 있다. 그러니 웬만하면 처음부터 빌더 패턴으로 설계를 하는 게 좋다.

### 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라.
- 싱글턴을 만드는 방법은 public static final 필드를 통해 인스턴스를 제공하는 방법과, 정적 팩터리 메서드를 통해 제공하는 방법이 있다.
- 필드방식의 장점은 해당 필드가 싱글턴임이 API에 명백히 드러난다는 것이고, 간결하다는 것 또한 장점이다.
- 정적 팩터리 방식의 장점은 API를 변경하지 않고도 싱글턴 여부를 변경할 수 있다는 것이다. 또한 스레드별로 다른 인스턴스를 넘겨줄 수도 있다.
- 둘 중 하나의 방식으로 구현한 클래스를 직렬화하려면, Serializable을 구현하는 것만으로는 부족하고, readResolve 메서드를 제공해야 역직렬화마다 가짜 객체가 생성되는 것을 방지할 수 있다.
   ```java
   // 싱글턴임을 보장해주는 readResolve 메서드
   private Object readResolve() {
       // 진짜 객체를 반환하고, 가짜 객체는 가비지 컬렉터에 맡긴다.
       return INSTANCE;
   }
   ```
- 싱글턴을 만드는 세번째 방법은 Enum타입을 선언하는 것이다.
   ```java
   public enum Elvis {
       INSTANCE
       public void leaveTheBuilding() {...}
   }
   ```
- 리플렉션 공격을 피할 수 있고, 추가적인 노력 없이 직렬화 할 수 있으나 Enum이외의 클래스를 상속할 수 없다는 단점이 있다.
- Enum 상속이 필요한 상황이 아니라면 Enum 싱글턴이 최선의 선택이다.

### 4. 인스턴스화를 막으려거든 private 생성자를 사용하라
- 정적 메서드와 정적 필드만을 담은 클래스와 같이 인스턴스화를 시키지 않는 클래스는 private 기본 생성자를 선언하여 인스턴스화를 막아라.
- 이 방식은 인스턴스화 불가 효과에 더해 상속 불가 효과도 갖는다.
- 다만 이런 방식은 비직관적이니 생성자에 목적을 주석으로 달아주는 것이 좋다.

### 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스의 동작에 영향을 준다면 싱글턴이나 정적 유틸리티 클래스는 사용하지 말자.
- 의존 객체 주입은 생성자에 필요한 자원을 넘겨주는 방식으로, 이미 많은 개발자들이 사용중인 패턴이다.
- 다만 자원이 너무 많다면 코드가 복잡해지는 문제가 있는데, 스프링과 같은 프레임워크를 사용하면 이같은 문제를 해결할 수 있다.

### 6. 불필요한 객체 생성을 피하라
- 특정 동작의 수행을 위해 사용하는 코드가 내부적으로 매번 새로운 객체를 생성하는 경우(ex. matches) 필요한 객체를 필드에 초기화 시켜 재사용하라.
- 기본타입을 래퍼객체로 변환해주는 오토박싱은 빈번한 호출에 사용될 시 불필요한 객체를 크게 양산할 수 있다. 가급적 기본타입을 사용하고 오토박싱이 숨어들지 않도록 주의하자.

### 7. 다 쓴 객체 참조를 해제하라
- JVM만 믿고 객체 생명주기를 신경쓰지 않다보면 자바에서도 메모리 누수가 일어날 수 있다.
- 로직상 프로그래머만 객체의 미사용 여부를 알 수 있고 JVM은 알 수 없는 케이스(ex. 리스트내 잔존 객체, 캐시 데이터)를 잘 파악하여 직접 참조해제를 해주자.
- 다만 이런 위험을 예방하기위해 모든 객체를 직접 참조 해제하는 것은 바람직하지 못하다. 직접 해제는 예외적인 경우에만 하자.

### 8. finalizer와 cleaner 사용을 피하라
- finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
- cleaner는 finalizer 보다는 덜 위험하지만 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.
- cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자. 물론 이런 경우라도 불확실성과 성능저하에는 주의해야 한다.

### 9. try-finally보다는 try-with-resource를 사용하라
- try-finally는 해제해야 하는 자원이 여러개일 시 중첩 블록이 발생하여 코드가 지저분해질 수 있다.
- 또한 중첩 try-finally 블록에서는 안쪽 블록에서 발생한 catch 예외를 바깥쪽 catch가 덮어버려 예외 추적이 힘들어진다.
- try-with-resource를 사용하면 여러 자원을 훨씬 깔끔하게 해제할 수 있고, 덮어씌워진 예외 또한 확인 가능해진다.
- 만일 직접 작성한 클래스도 자원 해제가 필요하다면 AutoCloseable 인터페이스를 구현하여 try-with-resource를 사용하자.
