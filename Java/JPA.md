## JPA(Java Persistence API)

### 기본 개념
- JPA가 특정 라이브러리나 패키지를 의미하는 게 아니라 자바에서 RDB를 사용하는 방식의 규약, 즉 인터페이스이다. 인터페이스이므로 직접적인 기능을 수행하지는 않는다.
- Hibernate는 JPA스펙에 따라 만들어진 대표적인 JPA구현체 중 하나이다.
- ORM(Object Relational Mapping)은 객체와 테이블을 매핑 시켜주는 기술을 의미
- SQL을 직접적으로 사용하지 않는 편의를 누리는 대신, 복잡한 쿼리를 많이 사용하는 시스템에서는 사용하기가 상당히 까다롭다.
- 위와 같은 문제를 보완하기 위해 JPA에서는 SQL쿼리와 거의 비슷한 방식으로 쿼리를 작성하여 사용할 수 있는 JPQL이라는 기술을 제공한다.


### 사용
- resources/META-INF/persistence.xml에 JPA 표준 속성을 정의.
- hibernate가 persistence.xml에 정의된 내용에 따라 EntityManagerFactory를 생성
  > EntityManagerFactory에서 EntityManager를 생성하여 영속성 컨텍스트*를 취득
- #### 영속성 컨텍스트?
    - JPA Entity를 영구저장하는 환경. 어플리케이션과 DB사이에서 객체를 보관하고 관리하는 가상의 공간
    - 영속성 컨텍스트의 4가지 상태
        1. 비영속 : 영속성 컨텍스트와 상관관계가 없는 상태
        2. 영속 : 영속성 컨텍스트에 저장된 상태
        3. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태(detach)
        4. 삭제 : 삭제된 상태
- #### 영속성 컨텍스트의 특징
  - **1차캐시** : 영속성 컨텍스트에 한 번 관리되었던 엔티티는 1차 캐시에 기록되고 이후 해당 엔티티에 대한 접근은 DB가 아닌 1차캐시를 통해 접근이 이루어짐.
  - **동일성 보장** : 한 엔티티를 여러번 조회하더라도 DB가 아닌 1차캐시에서 조회를 하기 때문에 조회된 엔티티는 모두 같음. 즉, 1차 캐시를 통해 RepeatableRead수준의 트랜잭션 격리수준을 제공한다고 할 수 있음.
  - **트랜잭션을 지원하는 쓰기지연** : persist()를 통해 영속성 컨텍스트에 저장하더라도, commit() 또는 flush()를 실행 하여 트랜잭션을 종료시키기 전에는 DB에 기록하지 않는다. 트랜잭션 종료 전의 insert&update쿼리는 쓰기지연SQL저장소에 쌓아둔다.
  - **변경감지** : 엔티티가 영속성 컨텍스트에 적재되는 순간의 상태를 스냅샷에 저장해두고, 트랜잭션 종료시점에 현 트랜잭션의 엔티티와 스냅샷의 엔티티를 비교, 차이가 있으면 업데이트 쿼리를 쓰기지연SQL저장소에 쌓고 커밋시킨다.


### 엔티티 매핑
- hibernate.hbm2ddl.auto 속성을 사용하여 매핑된 엔티티의 DDL을 런타임 시점에 자동으로 수행하게 할 수 있다.

  다만, 해당 기능은 위험성이 크므로 개발환경에서만 사용하도록 한다.

#### 1. 객체와 테이블 매핑(@Entity, @Table)
- @Entity에 name속성을 지정하지 않으면 클래스이름이 엔티티이름으로 사용됨
- 엔티티와 테이블 명이 다를 경우 @Table에 name을 지정해주어야 함
#### 2. 필드와 컬럼 매핑(@Column)
- 기본은 변수명과 같은 컬럼을 매핑하며 변수와 컬럼명이 다를 경우 @Column에 name을 지정해주어야함
- @Enumerated(enum타입매핑), @Temporal(날짜), @Lob(clob,blob) 등의 어노테이션 사용하여 매핑가능
- @Transient 어노테이션으로 매핑 무시 가능
#### 3. 기본 키 매핑(@Id)
- @GeneratedValue를 사용하면 자동으로 값을 할당
- @SequenceGenerator, @TableGenerator를 생성하여 시퀀스방식 또는 키생성 테이블 방식으로 설정 가능
- 시퀀스나 테이블 전략 사용 시 allocationSize 속성으로 한번에 호출할 값의 범위를 지정하여 최적화 가능
- Identity전략으로 DB에 키생성 위임가능(auto increment)
#### 4. 연관관계 매핑(@ManyToOne, @JoinColumn)
1. 다대일(N:1) 단방향 매핑
    - N에 해당하는 엔티티에서 외래키와 매핑 컬럼에 @ManyToOne 어노테이션을 사용하여 매핑
    - @JoinColumn을 사용하여 외래키 컬럼을 명시
2. 다대일 양방향 매핑
    - 양방향 매핑기술은 따로 존재하지 않고 단방향 + 단방향 매핑으로 양방향 매핑과 같이 구현
    - 단방향 매핑 방법에서 1에 해당하는 엔티티의 컬럼에 @OneToMany 어노테이션을 사용
    - @OneToMany속성에 mappedBy 속성으로 N에 해당하는 컬럼명을 반드시 명시해주어야함
    - 양방향 매핑은 관계의 복잡도를 크게 증가시키기 때문에 꼭 필요한 상황이 아니라면 가급적 자제
3. 일대다 단방향 매핑
    - 1에 해당하는 엔티티에서 @OneToMany어노테이션을 사용
    - @JoinColumn으로 기본키 컬럼을 명시
    - 엔티티가 관리하는 외래키가 다른테이블에 있고 연관관계 관리를 위해 추가UPDATE문이 실행되는 등의 단점이 있으므로 일대다 단방향 보다는 다대일 양방향을 사용하는 게 더 좋음
4. 일대일 단방향 매핑
    - 어느 엔티티에서 매핑을 해도 무방함. 일대다 방식의 매핑과 거의 유사
    - @OneToOne어노테이션, @JoinColumn(name="")으로 관계테이블의 외래키 명시
    - 양방향으로 할 경우 반대 엔티티에 @OneToOne추가 및 연관관계의 주인이 아닌 컬럼에 mappedBy로 매핑컬럼 명시
5. 다대다 매핑
    - @ManyToMany어노테이션은 존재하나 실무에서는 사용하지 않음
    - 다대다 관계의 표현을 위해 중간 테이블이 자동생성되나, 해당 테이블에 의도치 않은 값이 들어가는 경우가 있어 문제의 소지가 다분.
    - 이런 관계는 중간 테이블을 엔티티로 만들고 @OneToMany, @ManyToOne으로 관리를 하는 방식으로 해결


#### 5. 상속관계 매핑(@Inheritance(strategy = [InheritanceType.XXX](http://inheritancetype.xxx/)) )
1. 조인 전략
    - 정규화된 테이블의 구조를 따라 엔티티를 매핑하는 매핑방법, 일반적으로 가장 권장하는 방법이다.
    - 장점 : 저장공간 효율화, 외래키 참조 무결성 제약조건 활용가능
    - 단점 : 조회시 많은 조인으로 인한 성능 저하, 조회쿼리가 복잡, Insert쿼리 2번 호출
2. 단일테이블 전략
    - 자식클래스의 모든 컬럼을 부모클래스 테이블 하나에 몰아서 하나의 테이블로 관리하는 전략.
    - 장점 : 조인을 사용하지 않으므로 조회성능이 빠름, 조회쿼리 단순화
    - 단점 : 자식엔티티가 매핑한 컬럼은 모두 null허용, 모두 한 테이블에 저장하므로 테이블이 너무 커질 수 있고, 상황에 따라 오히려 성능이 저하될 수 있다.
3. 구현 클래스마다 테이블 전략
    - 단일 테이블과 반대로 부모 테이블 없이 부모 클래스의 컬럼을 상속받은 자식 테이블만 생성하여 관리하는 전략. 통합해서 관리하기가 어려우므로 DB전문가와 ORM전문가가 모두 추천하지 않는 전략.
    - 장점 : 서브타입을 명확하게 구분해서 처리할 때 효과적
    - 단점 : 여러 자식테이블을 조회할 때 union을 사용하므로 성능저하 발생, 통합관리의 어려움
    

### N+1문제
- 연관관계가 설정된 엔티티를 조회할 때, 조회된 연관관계 데이터의 개수만큼의 쿼리가 추가로 발생하는 문제
- ex) Team-Member 연관관계에서, 팀 엔티티를 조회할 경우, 팀을 조회하는 쿼리 하나와, 해당 팀에 소속된 멤버를 조회하는 쿼리 N개가 추가로 발생하는 것
- 기본적으로 지연로딩(FetchType.LAZY)으로 한번에 N개의 데이터를 모두 조회하는 상황을 막을 수는 있지만, n개 데이터에 대한 접근이 빈번한 경우에는 결국 성능저하가 발생할 수 있다.
- #### 해결방법
    - n+1문제를 방지하고자 하는 엔티티 조회쿼리에 fetch조인을 적용한다.
    - ex) select t from Team t join fetch t.members
    - fetch조인 이외의 방법으로는 hibernate설정의 deafault_batch_fetch_size 를 이용하는 방법이 있다. n+1에서 추가적으로 조회가 일어나는 n의 개수가 성능상 꽤 부담이 된다 판단되는 기준개수로 설정하면 되는데, 일반적으로 500이나 1000을 설정한다.
    - 해당 설정(m)을 사용하면 n+1문제가 해결되는 것은 아니지만, n의 조회 횟수가 (n/m) + 1  이 되기 때문에 fetch join으로 한번에 모든 연관관계 데이터를 조회하기는 부담이 되고, 그렇다고 n번의 쿼리수행도 방치하기 애매할 때의 대책으로 적합하다.