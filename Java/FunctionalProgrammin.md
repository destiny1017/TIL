## 함수형 프로그래밍(Functional Programming) 

- #### 프로그래밍 패러다임의 변화
  - 명령형 프로그래밍 : 무엇을 할지보다 어떻게 할 것인지를 기술하는 방식
    - 절차지향 프로그래밍 : 진행되어야할 순차적인 처리과정을 표현하는 방식
    - 객체지향 프로그랴밍 : 객체들의 집합과 협력관계를 통해 프로그램의 상호작용을 표현하는 방식
  - 선언형 프로그래밍 : 어떻게 할지보다 무엇을 할 것인지를 기술하는 방식
    - 함수형 프로그래밍 : 순수 함수를 조합하여 프로그램을 만드는 방식
    
- #### 함수형 프로그래밍의 등장
  - 기존의 명령형 프로그래밍으로 개발을 해오던 개발자들은 소프트웨어의 규모가 커지고 유지보수 기간이 길어질수록 방대해지는 스파게티 코드를 유지보수하기가 매우 어렵다는 것을 깨달았다. 그리고 이를 해결하기위한 방안으로 함수형 프로그래밍이라는 기법에 관심을 갖게 되었다. 이는 프로그램 작동 방식에 대한 거의 모든 것을 작은 순수 함수로 나누어 문제를 해결하는 방식으로, 가독성을 높이고 유지보수를 용이하게 해준다.

- #### 함수형 프로그래밍의 특징
  > 부수 효과가 없는 순수 함수를 1급 객체로 간주하여 파라미터나 반환값으로 사용할 수 있으며, 참조 투명성을 지킬 수 있다.
  - 부수효과(Side Effect)란?
    - 변수의 값이 변경됨
    - 자료구조를 제자리에서 수정함
    - 객체의 필드값을 설정함
    - 예외나 오류가 발생하여 실행이 중단됨
    - 콘솔 또는 파일 I/O가 발생함
  - 순수함수(Pure Function)란?
    - 함수 자체가 독립적이며 부수효과가 없고 Thread-safe하다.
    - Thread-safe 특성으로인해 병렬처리를 동기화 없이 진행가능하다.
  - 1급 객체(First-Class Object)
    - 변수나 데이터 구조 안에 담을 수 있다.
    - 파라미터로 전달할 수 있다.
    - 반환값으로 사용할 수 있다.
  - 참조 투명성(Referential Transparency)
    - 동일한 인자에 대해 항상 동일한 결과를 반환해야 한다.
    - 참조 투명성을 통해 기존의 값은 변경되지 않고 유지된다(Immutable Data)   
     
  명령형 프로그래밍의 함수와 함수형 프로그래밍의 함수의 가장 큰 차이는 부수효과의 유무이다. 프로그램 동작의 흐름을 순수 함수로 표현하고, 부수효과를 없애 직관적으로 이해할 수 있도록 하는 데에 함수형 프로그램의 목적이 있다. 그리고 이런 순수함수의 특징으로 인해 병렬환경에서 동시성 제어에 대한 비용을 줄여주는 효과도 있다.

- #### 예시

  ```java
    public class WordProcessTest {
    
        private final List<String> words = Arrays.asList("TONY", "a", "hULK", "B", "america", "X", "nebula", "Korea");
    
        @Test
        void wordProcessTest() {
            String result = words.stream()
                    .filter(w -> w.length() > 1)
                    .map(String::toUpperCase)
                    .map(w -> w.substring(0, 1))
                    .collect(Collectors.joining(" "));
    
            assertThat(result).isEqualTo("T H A N K");
        }
    }
  ```
    이와 같은 Stream, Lambda 방식의 코드가 함수형 프로그래밍의 대표적인 예이다. 코드를 하나하나 살펴보면 위에서 설명한 함수형 프로그래밍의 특징이 모두 드러난다. 어떻게하는지보다 함수명으로 무엇을 하는지를 기술하고 있고, 어떤 함수도 기존의 값을 변화시키지 않는다.


###### Reference : https://mangkyu.tistory.com/111  

### Functional Interface
  
함수형 인터페이스는 단일 추상메서드만을 가지는 인터페이스로서, 함수형 프로그래밍을 실현시키는 핵심적인 요소이다.  
단일 추상메서드라는 규약을 지키면 함수형 인터페이스로 볼 수 있긴하지만, 자바에서 함수형 인터페이스는 @FunctionalInterface 어노테이션이 선언되어 이 규약을 강제하여 구현하는 것이 일반적이다.  

- **함수형 인터페이스의 사용법**  
  함수형 인터페이스는 일반적인 인터페이스와 그 목적이나 용도면에서 큰 차이가 존재한다. 구현한 함수형 인터페이스는 특정 클래스에 상속되기보다는 메서드의 파라미터로 사용되며, 비즈니스 로직의 호출부에서 직접 동작을 정의하여 사용한다. 호출 시 람다 표현식을 통해 매우 간결하게 인터페이스의 동작을 정의할 수 있다.
  ```java
  // 함수형 인터페이스 정의
  @FunctionalInterface
  interface GreetingService {
    void sayHello(String name);
  }
  
  public class Main {
    public static void main(String[] args) {
      // GreetingService를 람다식으로 구현
      GreetingService greetingService = name -> System.out.println("Hello, " + name);
  
      // 람다식을 사용하여 함수 실행
      greetingService.sayHello("Alice");
      
      // 동일한 함수로 여러 매개변수를 유연하게 처리
      greetUser("Alice", name -> System.out.println("Hello, " + name));
      greetUser("Bob", name -> System.out.println("Hi, " + name));
    }
  
    public static void greetUser(String name, GreetingService greetingService) {
      greetingService.sayHello(name);
    }
    
  } 
  ```  
- **자바에서 제공하는 Functional Interface**  
  함수형 인터페이스의 형태를 보면 알 수 있듯이, 인터페이스가 담는 정보는 리턴타입, 파라미터 타입 및 개수, 함수명 정도 뿐이므로 사실 많은 함수형 인터페이스를 구현할 일은 거의 없다.  
  그래서 자바는 보편적으로 많이 사용되는 형태의 함수형 인터페이스들을 기본 라이브러리로 제공하는데, 대표적인 자바의 함수형 인터페이스 종류는 아래와 같다.

  | 함수형 인터페이스 이름   | 설명                     | 추상 메서드            |
  |----------------|------------------------|-------------------|
  | Runnable       | 특정 동작을 수행한다.           | void run()        |
  | Consumer<T>    | 객체 T를 받아 소비한다.         | void accept(T t)  |
  | Supplier<T>    | 객체T를 반환한다.             | T get()           |
  | Function<T, R> | 객체T를 객체 R로 매핑한다.       | R apply(T t)      |
  | Predicate<T>   | 객체T를 받아 boolean을 반환한다. | boolean test(T t) |  
  
  이런 기본 제공 인터페이스들에서 대부분의 상황에 대한 인터페이스들을 제공하므로, 이것을 활용하면 별도의 구현 없이 함수형 프로그래밍을 할 수 있다.


**함수형 인터페이스의 장점**  
- **코드 간결성 및 가독성 향상**  
    - 함수형 인터페이스를 사용하면 별도의 구현 클래스를 만들 필요가 없어 코드를 간결하게 작성할 수 있다.
    - 람다식을 사용해 코드의 의도가 명확하게 드러나며, 특히 익명 내부 클래스를 대체하여 코드의 가독성을 높인다.
- **유연한 코드 설계**  
  - 함수를 매개변수로 전달할 수 있어, 동적 동작 정의가 가능하다. 예를 들어, Consumer 인터페이스를 이용해 처리 방식을 매개변수로 전달하면, 동일한 메서드가 다양한 작업을 수행하도록 할 수 있다.
  - 컬렉션, 스트림 API와 함께 사용 시 복잡한 데이터 처리나 필터링 작업을 간단하게 작성할 수 있다.
- **스트림 API와의 높은 호환성**  
  - 자바의 스트림 API는 함수형 인터페이스를 기반으로 설계되어, 스트림 API와의 결합도가 높습니다.
  - 스트림에서 데이터를 필터링, 매핑, 수집하는 과정을 함수형 인터페이스를 통해 구현할 수 있습니다.
    
**함수형 인터페이스의 단점**  
- **디버깅이 어려움**
  - 람다 표현식은 컴파일러에 의해 내부적으로 변환되어 익명 메서드로 처리되기 때문에, 디버깅 시 호출 스택 추적이 어렵고, 람다식 내의 복잡한 로직은 디버깅하기가 까다로울 수 있다.  
- **런타임 성능 이슈**
  - 람다식은 내부적으로 익명 클래스 구현을 생성하기 때문에, 지나치게 많은 람다식을 사용하거나 중첩된 람다식을 사용할 경우 메모리 및 성능에 영향을 줄 수 있다. 특히 JIT 컴파일 최적화가 제한되는 경우 성능 저하가 발생할 수 있다.