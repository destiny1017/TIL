## Clustered / Non-Clustered Index
1. 클러스터 인덱스
   
   ![cluster index](https://github.com/destiny1017/TIL/assets/44860334/aa05b8a0-b267-4ede-af5b-bafe8635382d)

   - PK 설정시 자동으로 만들어지는 인덱스
   - 테이블당 1개만 허용
   - 데이터는 항상 정렬 상태를 유지함
   - 정렬 상태이기 때문에 데이터의 검색 속도는 빠르나 삽입 삭제의 속도는 느림
   - 리프노드가 데이터 페이지를 다이렉트로 바라보고 있다
  
2. 넌클러스터 인덱스
   
   ![non-cluster index](https://github.com/destiny1017/TIL/assets/44860334/0d07ad4d-183b-417b-9804-f932e83eecc0)
   
   - 상황에 따라 사용자가 직접 생성하는 인덱스로, 테이블당 약 240개까지 생성 가능
   - 데이터를 직접 정렬시키는 게 아니라 인덱스 페이지만 정렬하여 삽입 삭제가 비교적 빠름
   - 리프노드 페이지에는 데이터가 아니라 데이터를 바라보는 포인터가 key:value 형태로 들어가있음


## B-Tree
1. B-Tree의 구조
   - Binary Tree를 확장시켜 각 노드에 2개 이상의 데이터가 들어갈 수 있는 트리구조
   - 모든 데이터는 정렬된 상태로 삽입된다
   - Root - Branch - Leaf 의 3depth node 구조를 가지므로 모든 Leaf node들이 같은 레벨에 존재한다
   - B-Tree Index의 각 node에는 단일 데이터가 아닌 page(or block)라고 하는 데이터의 집합이 존재한다.
2. B-Tree Index의 특징
   - Index 성능에 영향을 주는 요소
      1) PK데이터의 크기
         - 인덱스는 기본적으로 리프노드에 PK의 위치를 저장한다(Non-Clustered)
         - PK의 크기가 클수록 한 페이지에 담을 수 있는 PK의 정보도 줄어들고, 이는 탐색의 비효율성을 초래한다
      2) Index Column의 순서
         - index의 기준 컬럼이 여러개일 경우, 후순위 컬럼은 앞의 컬럼 기준으로 정렬된다
         - 그렇기에 후순위로 지정된 컬럼으로 where 조건 검색을 실행할 경우, index를 효율적으로 타지 못한다.
      3) Cardinality
         - 데이터의 중복도가 낮을수록(유니크할수록) 카디널리티가 높다고 표현한다.
         - Index로 데이터를 읽어들일 경우, 카디널리티가 낮은 데이터이면 한번에 중복으로 읽어들이는 데이터가 많아 효율성이 떨어진다
   - Record Insert/Update/Delete가 Index에 미치는 영향
      1) Insert
         - 인덱스의 데이터는 정렬되어 있어야하기 때문에 데이터 추가시 인덱스 정렬작업이 추가로 발생한다.
         - 한 테이블에 걸려 있는 인덱스가 여러개라면 그만큼 한번의 추가에 따른 추가 정렬작업이 많이 발생하므로 삽입 효율이 떨어지게 된다.
         - 그래서 쓰기지연을 활용하여 삽입에 따른 오버헤드를 줄일수도 있지만, 유니크 인덱스의 경우 중복체크등의 무결성 작업 때문에 즉각반영이된다.
         - 유니크 인덱스는 쓰기작업에 따른 오버헤드가 더 큰편이므로 정말 유일성이 필요한 경우에만 유니크 인덱스를 생성하는 것이 좋다.
      2) Delete
         - 데이터 삭제시에는 유니크 인덱스에 특별히 불리한 점은 없지만, 삭제 후 정렬이 일어나는 점은 동일하다.
      3) Update
         - 수정작업의 경우 삽입과 삭제가 동시에 일어나는 작업이다.
         - 그렇기에 PK나 Index 데이터의 경우 추가 정렬작업이 발생하므로 이 두 데이터는 최대한 수정작업을 피하는 것이 좋다.
         - 그 외의 값은 테이블의 데이터만 직접 작업하믄 되므로 부담이 덜한 편이다.
      4) Select
         - 읽기 작업의 경우도 PK, Index, 일반 데이터 각각의 경우에 따라 다르게 수행된다.
         - PK는 Clueted index이므로 바로 데이터에 접근이 가능하여 가장 검색효율이 좋다. 또한 유니크 값의 경우 하나의 데이터만 찾으면 탐색이 중지된다
         - Index는 실제 데이터로 접근하는 과정이 한 번 더 있어 PK보다는 느리지만 그래도 일반데이터에 비하면 매우 빠른 편이다.
         - 일반 데이터는 테이블 풀스캔이 돌아가므로 가장 느리다.

           
